(begin
(define (set-cdr! list value)
  (set! list (cons (car list) value)))
(define (equal? a b)
  (if (not (pair? a))
    (if (not (pair? b))
      (eq? a b)
      (equal? a (car b)))
    (if (not (pair? b))
      (equal? (car a) b)
      (equal? (car a) (car b)))))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
(define (for-each proc list)
  (if (null? list)
      (quote done)
      (begin
	(proc (car list))
	(for-each proc (cdr list)))))
(define (map f xs)
  (if (null? xs)
      xs
      (cons (f (car xs)) (map f (cdr xs)))))
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
		(display register-name)
		((machine (quote allocate-register)) register-name))
              register-names)
    ((machine (quote install-operations)) ops)
    ((machine (quote install-instruction-sequence))
     (assemble controller-text machine))
    machine))
(define (make-register name)
  (let ((contents (quote *unassigned*)))
    (define (dispatch message)
      (cond ((eq? message (quote get)) contents)
            ((eq? message (quote set))
             (lambda (value) (set! contents value)))
            (else
              (error "Unknown request -- REGISTER" message))))
    dispatch))
(define (get-contents register)
  (register (quote get)))
(define (set-contents! register value)
  ((register (quote set)) value))
(define (make-stack)
  (let ((s (quote ()))
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
        (error "Enpty stack -- POP")
        (let ((top (car s)))
          (set! s (cdr s))
          (set! current-depth (- current-depth 1))
          top)))
    (define (initialize)
      (set! s (quote ()))
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      (quote done))
    (define (print-statistics)
      (newline)
      (display (list (quote total-pushes) (quote =) number-pushes
                     (quote maximum-depth) (quote =) max-depth)))
    (define (show) s)
    (define (dispatch message)
      (cond ((eq? message (quote push)) push)
            ((eq? message (quote pop)) (pop))
            ((eq? message (quote show)) (show))
            ((eq? message (quote initialize)) (initialize))
            ((eq? message (quote print-statistics))
             (print-statistics))
            (else (error "Unknown request -- STACK"
                         message))))
    dispatch))
(define (pop stack) (stack (quote pop)))
(define (show stack) (stack (quote show)))
(define (push stack value) ((stack (quote push)) value))
(define (make-new-machine)
  (let ((pc (make-register (quote pc)))
        (flag (make-register (quote flag)))
        (stack (make-stack))
        (the-instruction-sequence (quote ())))
    (let
      ((the-ops
         (list (list (quote initialize-stack)
                     (lambda () (stack (quote initialize))))
               (list (quote print-stack-statistics)
                     (lambda () (stack (quote print-statistics))))))
       (register-table
         (list (list (quote pc) pc) (list (quote flag) flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
          (error "Multiply defined register: " name)
          (set! register-table
            (cons (list name (make-register name))
                  register-table)))
        (quote register-allocated))
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
            (cadr val)
            (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
            (quote done)
            (begin
              ((instruction-execution-proc (car insts)))
              (execute)))))
      (define (dispatch message)
        (cond ((eq? message (quote start))
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message (quote install-instruction-sequence))
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message (quote allocate-register)) allocate-register)
              ((eq? message (quote get-register)) lookup-register)
              ((eq? message (quote install-operations))
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message (quote stack)) stack)
              ((eq? message (quote operations)) the-ops)
              (else (error "Unknown request -- MACHINE" message))))
      dispatch)))
(define (start machine)
  (machine (quote start)))
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  (quote done))
(define (get-register machine reg-name)
  ((machine (quote get-register)) reg-name))
(define (assemble controller-text machine)
  (extract-labels controller-text
                  (lambda (insts labels)
                    (update-insts! insts labels machine)
                    insts)))
(define (extract-labels text receive)
  (if (null? text)
    (receive (quote ()) (quote ()))
    (extract-labels (cdr text)
                    (lambda (insts labels)
                      (let ((next-inst (car text)))
                        (if (symbol? next-inst)
                          (receive insts
                                   (cons (make-label-entry next-inst
                                                           insts)
                                         labels))
                          (receive (cons (make-instruction next-inst)
                                         insts)
                                   labels)))))))
(define (update-insts! insts labels machine)
  (let ((pc (get-register machine (quote pc)))
        (flag (get-register machine (quote flag)))
        (stack (machine (quote stack)))
        (ops (machine (quote operations))))
    (for-each
      (lambda (inst)
        (set-instruction-execution-proc!
          inst
          (make-execution-procedure
            (instruction-text inst) labels machine
            pc flag stack ops)))
      insts)
    (display insts)))
(define (make-instruction text)
  (cons text (quote ())))
(define (instruction-text inst)
  (car inst))
(define (instruction-execution-proc inst)
  (cdr inst))
(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
(define (make-label-entry label-name insts)
  (cons label-name insts))
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
      (cdr val)
      (error "Undefined label -- ASSENBLE" label-name))))
(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) (quote assign))
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) (quote test))
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) (quote branch))
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) (quote goto))
         (make-goto inst machine labels pc))
        ((eq? (car inst) (quote save))
         (make-save inst machine stack pc))
        ((eq? (car inst) (quote restore))
         (make-restore inst machine stack pc))
        ((eq? (car inst) (quote perform))
         (make-perform inst machine labels ops pc))
        ((eq? (car inst) (quote show-stack))
         (make-show-stack stack pc))
        (else (error "Unknown instruction type -- ASSENBLE"
                     inst))))
(define (make-show-stack stack pc)
  (lambda ()
    (display "\nstack :: ")
    (display (show stack))
    (display "\n\nnext -> ")
    (display (caar (cdr (get-contents pc))))
    (display "\n---------\n")
    (advance-pc pc)))
(define (make-assign inst machine labels operations pc)
  (let ((target
          (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
            (if (operation-exp? value-exp)
              (make-operation-exp 
                value-exp machine labels operations)
              
              (make-primitive-exp 
                (car value-exp) machine labels))))
      (lambda ()
        (set-contents! target (value-proc))
        (advance-pc pc))))) 
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst))) 
    (if (operation-exp? condition)
      (let ((condition-proc
              (make-operation-exp
                condition machine labels operations)))
        (lambda ()
          (set-contents! flag (condition-proc))
          (advance-pc pc)))
      (error "Bad TEST instruction -- ASSENBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst))) 
    (if (label-exp? dest) 
      (let ((insts
              (lookup-label labels (label-exp-label dest)))) 
        (lambda ()
          (if (get-contents flag)
            (set-contents! pc insts)
            (advance-pc pc))))
      
      (error "Bad BRANCH instruction -- ASSENBLE" inst))))
(define (branch-dest branch-instruction)
  (cadr branch-instruction))
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst))) 
    (cond ((label-exp? dest)
           (let ((insts
                   (lookup-label labels
                                 (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest) 
           (let ((reg
                   (get-register machine
                                 (register-exp-reg dest)))) 
             (lambda ()
               (set-contents! pc (get-contents reg)))))
      (else (error "Bad GOTO instruction -- ASSENBLE"
                   inst)))))
(define (goto-dest goto-instruction)
  (cadr goto-instruction))
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst)))) 
    (lambda ()
      (push stack (get-contents reg)) 
      (advance-pc pc))))
(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack)) 
      (advance-pc pc))))
(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst))) 
    (if (operation-exp? action)
      (let ((action-proc
              (make-operation-exp
                action machine labels operations)))
        (lambda ()
          (action-proc)
          (advance-pc pc)))
      (error "Bad PERFORM instruction -- ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp))) 
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                 (lookup-label labels
                               (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
    (else
      (error "Unknown expression type -- ASSENBLE" exp))))
(define (tagged-list? exp tag)
  (if (pair? exp)
    (eq? (car exp) tag)
    false))
(define (register-exp? exp) (tagged-list? exp (quote reg)))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp (quote const)))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp (quote label)))
(define (label-exp-label exp) (cadr exp))
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations)) 
        (aprocs
          (map (lambda (e)
            (make-primitive-exp e machine labels))
               (operation-exp-operands exp)))) 
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) (quote op))))
(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
      (cadr val)
      (error "Unknown operation -- ASSEMBLE" symbol))))
(define gcd-text
  (quote (test-b
	  (test (op =) (reg b) (const 0))
	  (branch (label gcd-done))
	  (assign t (op rem) (reg a) (reg b))
	  (assign a (reg b))
	  (assign b (reg t))
	  (goto (label test-b))
	  gcd-done)))
(define gcd-machine
  (make-machine
   (quote (a b t))
   (list (list (quote rem) remainder) (list (quote =) =))
   gcd-text))
(set-register-contents! gcd-machine (quote a) 206)
(set-register-contents! gcd-machine (quote b) 40)
(start gcd-machine)
(get-register-contents gcd-machine (quote a))
)
